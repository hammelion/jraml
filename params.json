{"name":"Jraml","tagline":"raml, java, jraml, rest, api, jaxrs","body":"# Purpose of project\r\nJraml helps you build your java implementation of REST API, based on specification, described by raml file.\r\n\r\n# Easy to use\r\n## Connect a library\r\n```xml\r\n...\r\n        <dependency>\r\n            <groupId>com.github.hammelion</groupId>\r\n            <artifactId>jraml</artifactId>\r\n            <version>0.2.2</version>\r\n        </dependency>\r\n...\r\n```\r\n## Add listener to your servlet container configuration (web.xml)\r\n```xml\r\n...\r\n    <listener>\r\n        <listener-class>com.github.hammelion.JRamlBootstrap</listener-class>\r\n    </listener>\r\n...\r\n```\r\n## Annotate your resources with **@RAMLConfig** annotation\r\n```java\r\n...\r\n@RAMLConfig(\"api.raml\")\r\npublic class TestResource {\r\n...\r\n```\r\n`api.raml` should be on resources classpath\r\n\r\n# How it works\r\nJraml reads RAML file and annotates your java classes with JAX-RS annotations in runtime. You can then use any JAX-RS implementation ([Jersey](https://jersey.java.net/), [RestEASY](http://resteasy.jboss.org/), [Restlet](http://restlet.com/), etc.) with your @RAMLConfig-annotated REST resources.\r\n\r\nYou can generate your first REST API implementation using [RAML for JAX-RS](https://github.com/mulesoft/raml-for-jax-rs).\r\n\r\nTo ensure, that your java implementation reflects your RAML specification, use Jraml. It helps you keep your RAML specification and java implementation in sync.\r\n\r\n# Naming conventions\r\nIn order to map RAML structure to java code you should name your classes, methods and parameters according to the following convention:\r\n## Class name\r\nA java class represents a specific RAML Resource. That is why the class name should end with **Resource**. E.g.:\r\n\r\nTo define REST URL `/test` we specify it in RAML file:\r\n```xml\r\n/testResource:\r\n```\r\nBy using JAX-RS we would annotate our java code as follows:\r\n```java\r\n@Path(\"/test\")\r\npublic class AnyClassName {\r\n```\r\nAnd with JRAML the code transforms into:\r\n```java\r\npublic class TestResource\r\n```\r\n## Method name\r\nA java method represents a specific action on RAML Resource. That is why the method name should start with action name. E.g.:\r\n\r\n### GET\r\nTo define GET on `/test` URL we specify it in RAML file:\r\n```xml\r\n/testResource:\r\n  get:\r\n```\r\nBy using JAX-RS we would annotate our java code as follows:\r\n```java\r\n@Path(\"/test\")\r\npublic class AnyClassName {\r\n...\r\n@GET\r\npublic ReturnType methodName() {\r\n```\r\nAnd with JRAML the code transforms into:\r\n```java\r\npublic class TestResource\r\n...\r\npublic ReturnType getAnyMethodName()\r\n```\r\n### POST\r\nTo define POST on `/test` URL we specify it in RAML file:\r\n```xml\r\n/testResource:\r\n  post:\r\n```\r\nBy using JAX-RS we would annotate our java code as follows:\r\n```java\r\n@Path(\"/test\")\r\npublic class AnyClassName {\r\n...\r\n@POST\r\npublic ReturnType methodName() {\r\n```\r\nAnd with JRAML the code transforms into:\r\n```java\r\npublic class TestResource\r\n...\r\npublic ReturnType postAnyMethodName()\r\n```\r\n### PUT\r\nTo define PUT on `/test` URL we specify it in RAML file:\r\n```xml\r\n/testResource:\r\n  put:\r\n```\r\nBy using JAX-RS we would annotate our java code as follows:\r\n```java\r\n@Path(\"/test\")\r\npublic class AnyClassName {\r\n...\r\n@PUT\r\npublic ReturnType methodName() {\r\n```\r\nAnd with JRAML the code transforms into:\r\n```java\r\npublic class TestResource\r\n...\r\npublic ReturnType putAnyMethodName()\r\n```\r\n### DELETE\r\nTo define DELETE on `/test` URL we specify it in RAML file:\r\n```xml\r\n/testResource:\r\n  delete:\r\n```\r\nBy using JAX-RS we would annotate our java code as follows:\r\n```java\r\n@Path(\"/test\")\r\npublic class AnyClassName {\r\n...\r\n@DELETE\r\npublic ReturnType methodName() {\r\n```\r\nAnd with JRAML the code transforms into:\r\n```java\r\npublic class TestResource\r\n...\r\npublic ReturnType deleteAnyMethodName()\r\n```\r\n\r\n## Method parameters\r\nIt is a very good idea to ensure typization in your java REST API. You should do it by wrapping REST parameters in immutable [POJO](http://en.wikipedia.org/wiki/Plain_Old_Java_Object)s:\r\n\r\n```java\r\npublic final class MyParameter\r\n{\r\n   private final String value;\r\n\r\n   public Name(final String value)\r\n   {\r\n      this.value = value;\r\n   }\r\n\r\n   public String getValue()\r\n   {\r\n      return this.value;\r\n   }\r\n\r\n   @Override\r\n   public String toString()\r\n   {\r\n      return this.value;\r\n   }\r\n}\r\n```\r\n\r\nNow it is very easy to map REST parameters to your java implementation:\r\n### Query parameters\r\nTo define GET on `/test` URL with query parameters we specify it in RAML file:\r\n```xml\r\n/testResource:\r\n  get:\r\n    queryParameters:\r\n        myParameter:\r\n          type: string\r\n```\r\nBy using JAX-RS we would annotate our java code as follows:\r\n```java\r\n@Path(\"/test\")\r\npublic class AnyClassName {\r\n...\r\n@GET\r\npublic ReturnType methodName(MyParameter anyParameterName) {\r\n```\r\nAnd with JRAML the code transforms into:\r\n```java\r\npublic class TestResource\r\n...\r\npublic ReturnType getAnyMethodName(MyParameter anyParameterName)\r\n```\r\n# Useful links\r\n[RAML Website](http://raml.org/)\r\n[JAX-RS](http://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services)\r\n[RAML for JAX-RS](https://github.com/mulesoft/raml-for-jax-rs)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}